
Sort these functions 

n², nlogn, 1, logn, 2^n, n³, n

[Asymptotic analysis means we see the nature of the graph when n is a very high number. We don't care for the nature of graph for low numbers.]

--1, log n,n, nlogn, n², n³,2^n

Now second job is to draw the graphs of

Y = 2n

Y = 3n

Y = 4n
  In the same graph
Now we see, from the graph, the graph of 3n is always above the graph of 2n.
It means that for the same value of n, 3*n will be a greater value of 2*n
So we can say that 3n is an upper bound for 2n. Which means saying that whatever may happen the value of 2n wont exceed 3n.

Similarly n is a lower bound for 2n.
Now we may argue that 4n can be also an upper bound for 2n. The answer is yes, any graph that lies above 2n (for larger values of n) can be an upper bound.

 Now lets first come to what asymptotic analysis is and why we do it
.

Asymptotic analysis means studying a graph's nature for very large numbers.

Now the question is why large numbers only?
Because in real life situations we have huge amounts of data to work with like to handle the fb data of billions of users. In that case we need to know how efficiently our function can program with such a huge data set. 
If instead all we had to do was to run a loop 10 times, then no matter how bad the code is, it will run pretty quick.

For an idea of how quick a program can work. Check you phone's specs, it must be saying that you have a 1.7 giga (10¹²) hertz processor.

It simply means that agar your phone had no job other than running a loop from 1 to 1.7*10¹² then it could do it in 1 sec!

This is the reason we need to know the complexity of our algorithm. Let's see things into scale

If n = 1 billion
An O(n) algorithm runs in approximately 1 sec
An O(2^n) algorithm runs in approximately 380 days!
[Calculation: A normal c++ ide does 10^9 iterations in 1 sec

So if you are doing 2^(1000000000) = 10^(333333333) iterations then it will take you 333333333/9 seconds. That's around 380 days]

But if your n is small like

If n = 10
An O(n) algorithm takes 0.000001 sec
An O(2^n) algo takes 0.000002 sec

So if n is very small, it doesn't bother us much.

Now the notations,
First:
UPPER BOUND (Big-oh):

Let's take an example function 
f(n) = 4n + 6
Now If I want to find a function which can act as an upper bound I can simply point out the functions that are greater than it. Now from the list we can see that nlogn, n²,n³,2^n can act as the upper bound. 
But wait, we are forgetting n itself. Is there any function in the form of n that can be an upper bound of 4n+6?
5n,6n,7n,8n,...
Now we draw the graph for 4n+6 and 5n,
We can see that 5n will always be greater than 4n+6 when n gets large and large. So cool, we can say that 5n is an upper bound to 4n+6.

But if you notice, until one point, 5n ka graph is actually below 4n.
So after n = 6, 5n will act as an upper bound.

Now the definition 

g(n) - n (the element we choose from the list to make it an upper bound)

c - constant of g(n) (in this case its 5)

n0 - point where the graphs meet (in this case n0 = 6)

Now for 6n: g(n)- n
	    c- 6
	    n0- 3
So 
g(n) = nlogn, n²,n³,2^n
All of these can be an upper bound with any constant c. 
But when we take g(n) = n, we need to take only constants that give me an upper bound.

LOWER BOUND: omega(n)

4n+6
lower bounds: 3n, 2n, n logn, 1
g(n)-n
c- 3 
n0--6

TIGHT BOUND: thetha(n)

Now tell me c1 and c2 when c1*g(n) is a lower bound while c2*g(n) is the upper bound.
c1-3n 
c2-5n

For this we need to choose such a g(n) that uss same g(n) se you can make a lower bound as well as an upper bound just by changing its constant.
So bottom line for 
lower bound f(n)'s family function and its lower functions.
Upper bound ke liye f(n) ka family function and higher functions. For 
tight bound ke liye sirf family function.

Q)Now take a question n²+n+1
And tell me all possible values of upper, Lower and tight bounds and one example of all three parameters for each.

For upper bound:
n³,2^n


g(n)-n²

c- 2

n0- 1.61

For lower bound:

other lower bounds: nlogn, n, logn, 1
g(n): n²

c: 1

n0- -1

For tight bound:

g(n): n²

c1:n², c2: 2n²



